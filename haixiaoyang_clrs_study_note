一 总结

JUNE 25, 2013 LEAVE A COMMENT
第三遍过算法导论(CLRS)，用的是第三版。第一遍就是大致的浏览重要章节各种算法的伪代码和知识点。第二遍开始用java实现重要章节的伪代码，会大致过一下课后题，挑选其中觉得最有价值的实现(其实也没多少)。现在第三遍是再过一遍并分类总结和写一下笔记。
总体感觉是这本一千多页的书除了算法描述外有大量篇幅的证明，有些证明讲的很好但是很多证明讲的太严谨(繁琐？)，所以对于证明倒是先自己去想，能想通就不看，想不通说实话也不想看，其实很多算法是可以自己想办法去证明的。对于课后题我是实现没办法每个都看，就是重要章节大致的扫扫，有价值编程实现的就会自己实现，其实课后题很多还是论证和提问的形式。还有一些章节觉得比较偏的就会只看看或简单实现一下书上主要的伪代码，不想深入，更偏一点的直接不看。每章后面的problem也是挑重要的看，那种看题目意思就得20分钟的就直接过掉了。除去很偏的，过难的，证明论证什么没太大必要看的，感觉这本书信息量没有想得那么大，当然如果你以scientist的标准要求自己来读这本书那就艰深多了。
下面是我看这本书程度的描述 (平均每天花两，三个小时，大概两，三个月吧到现在，所以可以看出我看的并不是很深入)：
===========================================================
Chapter 1, Chapter 2, Chapter 3 太基础了跳过，简单时间复杂度分析。
Chapter 4, 很重要，有仔细看，做课后题。
Chapter 5, 我觉得重要，有仔细看，做课后题和problem. 这章对后面的分析平均时间复杂度很有帮助，也蛮有意思，这章好像没有需要编程实现的问题。
Chapter 6 ， 7 & 8, 非常重要，仔细看，实现伪代码，过课后题和problem，分析时间复杂度。
Chapter 9, 个人觉得挺重要，有仔细看，实现伪代码，过课后题和problem
Chapter 10, 最基本的数据结构，假定都会了，但还是有过一遍内容和课后题。
Chapter 11, 非常重要，仔细看，认真实现伪代码，过课后题和problem，另外分析平均时间复杂度。
Chapter 12, 非常重要，仔细看，认真实现伪代码，过课后题和problem
Chapter 13, 大致看了一下讲解，还没看完，了解了一下RBTree是什么而已
Chapter 14, 重要，仔细看并过一遍课后题和problem
Chapter 15, 写的最好的章节就是dp这章，需要仔细看，实现每道伪代码的讲解，实现三分之二的dp课后题和problem, 其中最有意思的问题作过两遍。
Chapter 16, 和Chapter 15一起看的，也很重要但没有15章重要。有仔细看，实现伪代码，过课后题和problem
Chapter 17, 偏了，觉得只看看aggregate analysis就可以了
Chapter 18, 大致看了一下讲解，了解了一下B- Tree
Chapter 19 & 20, 太偏了，跳过
Chapter 21, 不是很重要，但是有仔细看，大致过了一下课后题和problem
Chapter 22, 23, 24 & 25, 图论的4章，22张当然是最重要的，不过基本这4张除了25张松点外是以一个强度研究的。有实现大部分伪代码，课后题和少量problem。感觉后面3章的证明本身很重要，但书里写的太繁琐，自己证明就可以啦。
Chapter 26, 最大流问题， 太偏且难，不看
Chapter 27, 可以大致看看，还蛮有意思
Chapter 28, 29, 30, 31 太偏了没看，觉得Chapter 31可以看看模数定理，最大公约最小公倍的计算原理。
Chapter 32, 很重要，仔细看，过课后题和problem
Chapter 33, 理解一下叉乘，研究一下33.2的扫描算法，实现了33.1, 33.3的主要算法，33.4本来想实现来着，太懒了~~ -__-!
Chapter 34, 35不看， 是在恶心的看不下去了
=========================================================================
下面附上小尾羊(小肥羊) 0 ^__^ 0同学的总结:
=========================================================================
来源：http://www.mitbbs.com/article_t/JobHunting /31481405.html “Algorithms的书”：就面试而言，17，19，20，26，27，29，30，35这些章节不看应该是比较安全的。此外，21，31，34的内容在我看过的网上的面试题里面也涉及的比较少。如果你光是为了准备面试，有不少的数学的证明可以跳过，着重理解算法(及其思路)，学会分析复杂度。
第一部分里面的算法复杂度分析主定理什么的，肯定要闭着眼等能算的，3，4章吧(排
序什么这类基础问题就假定大家都会了，你要不会或者不熟可以去看看把基础打牢)
第二部分，6,7,8,9，必看，在面试里都会有涉及到，直接的，或者间接的
第三部分，10很基础，假定大家都会了。11，12相当重要，13章的RBT我觉得最好还是
至少弄懂明白个意思/思路，面试考到的机会不大就是了，不要求 你能写出来code来(
不过要是遇到bt的公司然后RBT的code也别来怪我啊，呵呵)，14的思想值得学习和体会
，14都属于比较进阶一点的内容了， 涉及到的面试题也算是难度等级较高的题目了
第四部分，15 16贪心动态在加个分冶，一定要大量练习加上好好体会思想多总结,非常
重要，非常有用
第五部分，18 B Tree加上个B+, 学数据库原理应该都会讲一些，这个东西我觉得还是
有些用处的，对于一些large scale题或者涉及到数据库实现的，19 20看看结论就好了
，从没看面试题目中出现过，21呢是高级进阶的东西，你如果学会了正好遇上用武之地
能说一说也会是很impressive的
第六部分，感觉面试考图考的不多也都比较基本，可能是觉得复杂算法不适合当场
coding？22肯定要熟悉的，23 24 25很少见到有直接考的(见过一道careercup上google
的题最短路径)，26 最大流基本上你可以放心不会碰到，不过我还真做过一道面试题用
最大流解(或者说匈牙利算法)，当然这些对于面试都是进阶的topics，有空有兴趣有余
力 可以看看
第7部分，27 28 29 30 31基本上很少见在面试中涉及过，29 31你也可以当进阶内容来
看；32要熟悉，考字符串的题目还是比较多的，33的内容对于面试有点进阶了，虽然说
33的内容在计算几何里面只是基本的，但我 觉得比如凸包的算法对应面试在难度上已
经有点溢出了，有兴趣想进阶的可以看看，还是看到过关于凸包的题目. 34 NP 跟面试
也离的比较远，不过也有变态的题目本身就是NP/NPC的，如果你能看出来，再说一番，
也能展现一下实力。35略过
=============================================================
二 分治算法和递归复杂度分析 (chapter 4)

JUNE 25, 2013 LEAVE A COMMENT
4.1 The maximum-subarray problem
很经典的一道题，本来是有O(n)的解法，但这里也给出了分治nlogn的解法。实现:
http://haixiaoyang.wordpress.com/2013/06/07/chapter-4-maximum-subarray-problem-nlogn-page-68/
感觉会比较有价值的课后题：
4.1-1 => 怎么应用在O(n) solution上?
4.1-5 => 说的就是O(n) solution:
http://haixiaoyang.wordpress.com/2012/07/13/sub-array-continue-sum-max/
4.2 Stranssen’s algorithm
书上说这个algorithm是最难的算法所以基本也没必要搞清楚。
一开始给了一个 divided & conquer的解法， 复杂度是这个公式：T(n) = 8T(n/2) + O(n^2)，这个时间复杂度还是O(n^3), 和brutal force一样
Stranssen 算法通过一系列乱七八糟的变化变为了T(n) = 7T(n/2) + O(n^2)， 根据证明巨复杂无比的master theory 这个公式的复杂度是O(n^2)。
觉得这个divided & conquer的解法实现还是挺有意思，这里代码处理了矩阵行列不是power of 2的情况：http://haixiaoyang.wordpress.com/2013/06/07/chapter-4-maximum-subarray-problem-nlogn-page-68/
这个分治算法虽然还是O(n^2), 但是后来又在chapter 27并行算法里有使用 (p794, chapter 27.2)
感觉会比较有价值的课后题：
4.2-2, 4.2-3, 4.2-6,
4.3 Substitution method
建立在数学归纳法上靠猜的复杂度分析
感觉会比较有价值的课后题：
4,3-1,2,3,6
4.4 recursion tree
主要教怎么画recursion tree, 通过recursion tree层数和每层复杂度估算总时间复杂度。
课后题都可以挑着画画看。其实通过recursion tree可以比较方便的分析Fibonacci递归算法的复杂度，这个干想还有点难。
4.5， 4.6 master theory and proof — 太难太理论了，跳过了
补充两道Divided and conquer的题：
Get number of pervert pairs: http://haixiaoyang.wordpress.com/wp-admin/post.php?post=125&action=edit
racer problem, 用pervert pairs的思路解决：http://haixiaoyang.wordpress.com/2013/06/07/clrs-divided-and-conquer-added-practice/

三 排序 (Chapter 6, 7, 8)

JUNE 25, 2013 LEAVE A COMMENT
Chapter 6
主要就是heapify, heap sot 和 priority queue 的各种基本操作，性质和时间复杂度. 课后题和讲解都很基本，problem 6-3 Young tableaus比较有价值。
有价值的课后题:
6.1-3, 6.1-5, 6.1-7, 6.2-3, 6.2-4, 6.2-6, 6.3-2, 6.4-3, 6.4-4 ==> 都是概念问题
6.5-8, 6.5-9
problems:
6-1, 6-2, 6-3
下面的code包含了大部分书中操作的实现和部分课后题
heapify & heap sort， problem 6-2:
http://haixiaoyang.wordpress.com/2013/06/09/heap-and-heap-sort/
priority queue:
http://haixiaoyang.wordpress.com/2013/06/09/chapter-6-5-page-162-priority-queue/
problem 6-3 Young tableaus
http://haixiaoyang.wordpress.com/2013/06/09/chapter-6-page-167-problem-6-3-young-tableaus/
Chapter 7
本章所有的code都在 http://haixiaoyang.wordpress.com/2013/06/09/chapter-7-all-code/
7.1 Description of quick sort
quick sort基础和各种变体，没什么好说的, code ：”quickSort”函数是最原始的实现.
课后题7.1-2处理了quick sort 对元素都相等数组O(n^2)复杂度的情况，函数”equalDepressedQuickSort”为我个人的一个具体实现。
7.3 A randomized version of quick sort
Quick sort 的 pivot取random sampling, 没多少内容
7.2 7.4 Analyze of quick sort
主要是分析quick sort的复杂度，比较难的是分析平均时间复杂度，需要用到chapter 5 indicator random variable的知识，否则肯定看不懂。
Chapter 7.4 讲的是基于比较的平均复杂度分析， ( Chapter 8描述的Sorting in linear time是非基于比较的排序 ), 比较次数就是算法的复杂度，比如冒泡排序是每个pair都比较所以是O(n^2)，快速排序partition好的话是不需要每个pair都比较的。
关键的indicator random variable: p(i,j) = 以排好序数组第i个元素和第j个会比较的概率。任何在i或j做为pivot之前被选择为pivot而切断[i, j]的情况都不能让i 和 j产生比较。
problem 7-3 直接根据公式 + substitution method证明平均复杂度是O(nlgn)
一个Facebook的quicksort变体的面试题 ==>主函数 “arrange”
problems 7-1 ==> 主函数 “hoareQuickSort”
problems 7-2 ===>主函数 “dedupedQuickSort”， 实际就是经典的three way partition
problem 7-3 从递归公式的较多分析平均复杂度
problem 7-6 主函数 “fuzzySort”
Chapter 8 Sorting in Linear Time
8.1 Lower bound of sorting
主要讲了一下基于比较的排序的原理 (decision tree)，证明了comparison sort 至少是O(nlgn)，可以了解一下。
8.2 Counting sort
算法描述的伪代码和原来想的不大一样，很奇怪为什么不在Counting数组(数组C)出来以后直接根据数组C输出排序结果，后来在看了Wiki的Radix sort的C代码才明白这么做是为了方便变化。比如x可能属于(-oo, +oo) 但是 f(x)可以隐射到[a, b], 用这种办法可以还原隐射前的x,参考radix sort.
8.3 Radix sort
这个比较重要,结合了counting sort, 有意思的是需要从least significant digit开始， 适用于正整数。
radix sort code:
http://haixiaoyang.wordpress.com/2013/06/12/chapter-8-3-radix-sort/
8.4 Bucket sort
code: http://haixiaoyang.wordpress.com/2013/06/12/chapter-8-4-bucket-sort/
很多课后的problems都没怎么看。

四 选择排序 & 哈希 (Chapter 9, 11)

JUNE 25, 2013 LEAVE A COMMENT
Chapter 9
9.1 Minimum and maximum
常见的用3n/2次比较 one pass 找出maximum 和 minimum
code: http://haixiaoyang.wordpress.com/2013/06/11/chapter-9-1-page-214-minimum-and-maximum/
9.2 Selection in expected linear time
就是讲selection sort, 后面又用了indicator random variable 分析了平均时间复杂度,不算难
code: http://haixiaoyang.wordpress.com/2013/06/11/chapter-9-2-page-215-selection-sort/
Problem 9-4 从另外一个角度分析了平均时间复杂度，这里复杂度的分析和quick sort那章基本一样, 一个是基于比较的一个是基于公式，based on indicator variable.
chapter 9.3
感觉这章本身有些偏， 但是有些课后题很好,
9.3-5， 9.3-6， 9.3-7， 9.3-8 这几题都很有价值
9.3-5 –> 二分的思想来做
9.3-6 –> 其实主要切分的那k-1个indexes不好确定
9.3-7 –> kth minimum 的变体，想法很巧
9.3-8 –> median of 2 sorted array, 感觉c语言写比java好些很多，java下标太容易出错
code: http://haixiaoyang.wordpress.com/2013/06/11/chapter-9-2-page-215-selection-sort/
problem 9-2 出的很好，可以仔细研究
code: http://haixiaoyang.wordpress.com/2013/06/11/chapter-9-problem-9-2-page-225/
problem 9-4 从基于comparison 的角度分析平均复杂度，和quick sort的分析很类似
Chapter 11
11.1 Direct address hash
讲的就是bitmap， 课后题 11.1-4 比较好
11.2 Hash tables
讲chained hashing, 有一个比较重要的load factor的概念，还有一个点是用indicator random variable 来分析hash操作的复杂度，分析的挺好，建议看懂。
课后题: 11.2-1 11.2-3 11.2-6
11.2-1 又是用indicator random variables 来分析
11.2-6 是一个很好的reject sampling的例子，需要用到page 1202的geometry distribution的概念，这有个stack overflow的解答：http://stackoverflow.com/questions/8629447/efficiently-picking-a-random-element-from-a-chained-hash-table
11.3 Hash functions
讲了几种hash的方法。其中multiplication method比较新, 和bucket sort的hashing有点类似
课后题: 11.3-1 11.3-2
11.3-2 要用到一些模除的性质
设f(i)为str[0..i] 代表的radix 128的数，那么f(i) = f(i-1) * radix + str[i], m(i)为f(i)%radix, 那么 m(i) = [ m(i-1)*radix + str[i] ] % h, h为number of slots. 这里和chapter 32.2描述的Rabin-Karp hash的preprocessing算法一样，都是解决over flow问题的。
11.4 Open address hashing
第一部分讲open address hashing by linear probing 的实现，很要注意的一点是删除的时候不能直接设空，否则search的时候会有问题。
code: http://haixiaoyang.wordpress.com/2013/06/13/chapter-11-4-open-address-hash/
接下来介绍了3种probing的方式，Linear probing, Quadratic probing 和double hashing
Linear probing 很容易造成clustering的情况使search的时间变长.
Quadratic probing会产生跳跃的probing, clustering的情况有很大缓解，但是对于很多key不同但hash key一样的情况会有second level clustering
Double hashing通过两个不同的hash函数来缓解second level clustering, 就是让hashing 更加random.
接下来是open address hashing的各种操作平均复杂度，还是indicator random variable的老路子
